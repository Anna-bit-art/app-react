let age = 18; // сам age, в переменной сидит само значение 18 (тк это примитив),
              // в примит значениях копируется само значения
let age1 = age; //копия/ссылка на age, так как значение 18 не может сидеть и в age и в age1, поэтому оно копипуется и в age1 сидит свое значение 18

let a = { // здесь уже сидит ссылка на объект, тк это не примитив, а объект
    name: 'Learning', //примитив
    protocol: "http", //примитив
    maxStudentsCount: 10, //примитив
    isOnline: true, //примитив
    students: ['Anna', 'Ivan', 'Pete'], //объект (массив)
    classroom: { //объект, не имеент свойств, имеет только ссылку на подъобъект teacher
        teacher: { //подъобъект
            name: 'Nikola',
            age: 18
        }
    }
}
// *************разбор объекта а******************
// примитивные значения сидят в самом объекте, а подъобъекты - нет, тк они независимы и где-то хранятся отдельно в памяти,
// а вложенность достигается с помощью ссылок. В массиве students хранятся примитивы, а сам массив хранится где-то отдельно
// засчет ссылки на этот массив, он кажется подъобъектом объекта а
// на объект classroom ссылается ссылка из а-объекта, а из classroom-объекта ссылается ссылка на teacher-объект.
// classroom-объект не имеет никаких свойств в себе, а только ссылку на подъобъект teacher
//
// на самом деле, когда мы объявляем переменную и присваиваем ей объект, мы присваиваем ей ссылку на объект (только имя)

let b = a; //копирование объекта а, но тк в а сидит только ссылка на объект, то в b будет тоже ссылка на тот же самый объект
b.name = 'spring';  // кажется, что меняем имя в объекте b, но у нас же его нет
                    // (есть только ссылка, кот =ссылке на а-объект, да и а нет, есть только ссылка)
console.log(b.name); // = spring
console.log(a.name); // = spring -> меняем один и тот же объект через разные ссылки. Новый b-объект не создался, скопировался a

// если нужно скопировать ОБЪЕКТ можно через spread-распостранение(...)???
let c = {...a }
console.log(c); // создали новый с-объект, в котором есть все, что в а-объекте
// но такое копирование объекта поверхностное - shallow copy - создается только один внешний объект и копируются примитивы
// вложенные объекты не копируются, а просто выставляются ссылки на них на объекты в памяти (те они не копируются).
console.log(c.name='winter'); // = winter - поменяли в с-объекте (примитивное значение)
// console.log(a.name); // = spring - осталось прежнее, тк объект скопирован

// но
c.students.push('Mary') // меняем массив только в c-объекте
console.log(c.students); // [ 'Anna', 'Ivan', 'Pete', 'Mary' ] - поменялся
console.log(a.students); // [ 'Anna', 'Ivan', 'Pete', 'Mary' ] - и здесь тоже, тк скопировалась ссылка на подъобъект, а не он сам

// сравниваем объекты, но по факту ссылки, на которые эти 2 объекта ссылаются
console.log(a === b); // true, так это ссылки
console.log(a === c); // false, тк 2 объекта не могут быть равны в любом случае, даже, если ни одинаковые, даже если они пустые
console.log(a.students === c.students); // true, тк это один и тот же объект, одна и та же ссылка

// те чтобы скопировать весь объект, нужно сделать копии всех вложенных объектов - deep copy
let d = { ...a };
d.students = [ ...a.students ]; //скобки!!!
d.classroom = { ...a.classroom };
d.classroom.teacher = { ...a.classroom.teacher };

console.log(d);
d.students.push('Nikita');
console.log(d.students); // [ 'Anna', 'Ivan', 'Pete', 'Mary', 'Nikita' ]
console.log(a.students);// [ 'Anna', 'Ivan', 'Pete', 'Mary' ]

console.log(a === d); // false - разн объекты/ссылки
console.log(a.students === d.students); // false разн подъобъекты/ссылки

// но примитивы, сравниваются по значению и если их значение равны, то true
console.log(a.name === d.name); // true - тк в a и d знвчения совпадают - 'spring'


